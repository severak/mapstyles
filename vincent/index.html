<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vincent style</title>
  <script src="https://unpkg.com/maplibre-gl@^5.6.1/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@^5.6.1/dist/maplibre-gl.css" rel="stylesheet" />
</head>
<body>
<script src="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.min.js"></script>
<link
        rel="stylesheet"
        href="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.css"
/>
<h1>Sever√°k's Vincent map style</h1>
<p>Very simple style focused on railways and public transport. <a href="https://github.com/severak/mapstyles/tree/master/vincent#readme">More info on Github</a></p>
<div id="map" style="height: 80vh"></div>
<div>
  <strong>Show/hide:</strong>
  <label><input name="tram or bus stop name" type="checkbox" checked onchange="showOrHide(this)"> public transport stops</label> |
  <label><input name="places,secondary place names" type="checkbox" checked onchange="showOrHide(this)"> place names</label> |
  <label><input name="minor boundary,state boundary" type="checkbox" checked onchange="showOrHide(this)"> borders</label> |
  <i>more features will be added here...</i>
</div>
<script>
  var map = new maplibregl.Map({
    container: 'map', // container id
    hash: true, // <- Enable hash routing
    style: './vincent_shortbread.json', // style URL
    center: [14, 50], // starting position [lng, lat]
    zoom: 15 // starting zoom
  });

  // GEOCODER
  const geocoderApi = {
    forwardGeocode: async (config) => {
      const features = [];
      try {
        const request =
                `https://nominatim.openstreetmap.org/search?q=${
                        config.query
                }&format=geojson&polygon_geojson=1&addressdetails=1`;
        const response = await fetch(request);
        const geojson = await response.json();
        for (const feature of geojson.features) {
          const center = [
            feature.bbox[0] +
            (feature.bbox[2] - feature.bbox[0]) / 2,
            feature.bbox[1] +
            (feature.bbox[3] - feature.bbox[1]) / 2
          ];
          const point = {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: center
            },
            place_name: feature.properties.display_name,
            properties: feature.properties,
            text: feature.properties.display_name,
            place_type: ['place'],
            center
          };
          features.push(point);
        }
      } catch (e) {
        console.error(`Failed to forwardGeocode with error: ${e}`);
      }

      return {
        features
      };
    }
  };
  map.addControl(
          new MaplibreGeocoder(geocoderApi, {
            maplibregl, zoom: 14
          })
  );

  const showOrHide = function (element){
    let layers = element.name.split(',');
    for (const layer of layers) {
      map.setLayoutProperty(layer, 'visibility', element.checked ? 'visible' : 'none');
    }
  }
</script>
</body>
</html>